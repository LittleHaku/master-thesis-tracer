% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{User Profile Structure and Generation}\label{chapter:user_profiles}

Once the model has been finished,
we use it to automatically generate user profiles for SENSEI.
These serve as test cases designed to verify
the discovered functionalities of the chatbot,
its handling of different inputs,
to check if the outputs match the expected value,
and to find other errors such as timeouts.

First, \autoref{sec:profile-structure}
will cover the structure of these profiles and how they work,
then \autoref{sec:profile-generation}
will cover how these profiles are generated from the infered model.


\section{User Profiles Structure}\label{sec:profile-structure}

A user profile contains all the information
that characterises the user,
the conversation goals,
interaction style,
and other information such as the \ac{LLM} that will be used,
or the number of conversations and turn per conversations.
These profiles are structured in a YAML file,
\autoref{code:yaml_profile} shows an example of a user profile generated by \ac{TRACER}.

\begin{figure}[htpb]
  \centering
  \lstinputlisting[
    language=yaml,
    caption={Example of a conversation profile for a pizzeria chatbot.},
    label={code:yaml_profile}
  ]{code/pizza_order_placement.yaml}
\end{figure}

To better understand how the profiles are generated,
we must first understand the profiles and their structure
made up of the \texttt{test\_name}
which as its name implies is a unique name for the profile,
followed by four different sections:
\texttt{llm}, \texttt{user}, \texttt{chatbot} and \texttt{conversation}.

\subsection{LLM Configuration (\texttt{llm})}

In this section we can choose the \acl{LLM} that we are going to use
along with its temperature.
The chosen \texttt{model} will have an impact on the achieved results
since each model has its own strengths and limitations
and there will be models that will perform better than others,
usually at the cost of being more expensive.
In this field we will just input the name of the model (e.g. \texttt{gpt-4o-mini}).
Then we have the \texttt{temperature},
this parameter controls the randomness of the \ac{LLM},
that is, when the model is going to choose the next word
how randomly it does it.
A value of 0 means that the model is deterministic
while 1 means that it will be more creative.

\subsection{User Persona Definition (\texttt{user})}

In the \texttt{user} section, we will define
the persona, its role, context and goals.
We start with the \texttt{language} that the user will employ,
followed by the \texttt{role} of the simulated user,
that is, a sentence representing who the user is
and what he ought to do (e.g., A customer ordering a pizza).
The \texttt{context} field provides additional information to the chatbot,
it can add more details or personality traits, such as,
"You are in a hurry", to make the simulated user more realistic.
The \texttt{goals} field is arguably the most important of the user's fields.
In it, we will describe all the objectives for the conversation.
These objectives are written like templates with placeholders
(e.g., Specify the pizza size as {{pizza\_size}}).
Below the list with all the objectives
we have the list of parameters, which is the placeholders we left in goals.
Each of these parameters will have assigned a function,
let it be \texttt{random()} where a random value of the data below will be taken,
or \texttt{random(x: int)}, in which case $x$ different random values will be taken.
Then we have the \texttt{forward()} or \texttt{forward(x)},
which will take in order a single value or $x$ values respectively.
Lastly, the nested forward, \texttt{forward(var)},
allows to cycle through all the combinations of a pair (or more, depending on the nested combinations) of variables.
For example, one could nest pizza sizes with pizza types,
that means that all combinations of pizza sizes with pizza types would be tested,
that is, small pepperoni, small four chesee, ..., medium pepperoni, medium four chesee, ..., large pepperoni, large four chesee...
After the function, we can specify its \texttt{type},
with values like int, float, string or date.
Right after that, we have the data field,
where we will input a list of values
or if it is a numeric value, a range with min and max
and the step to go from the min to the max.

\subsection{Chatbot Settings (\texttt{chatbot})}

Here, expected behaviour of the system under test will be specified.
The first field is the \texttt{fallback},
this is the sentence given by the chatbot when he cannot understand what the user is saying,
or what he is saying is outside of the chatbot's scope.
Next we have the \texttt{outputs}, a field similar to the goals
but in this case instead of being related to the inputs,
it will be used to extract outputs from the chatbot.
For each output we will give a name
then a \texttt{type} which can be string, money, int, float or date;
then we have a short \texttt{description}.
This information will be used by an \ac{LLM}
to extract the information from the conversation with the chatbot.


\subsection{Conversation Control (\texttt{conversation})}

This last section controls aspects of the execution.
The \texttt{number} will control the number of times the conversation will take place,
the more conversations, the more combinations of the goals' items to be tested.
This field allows an integer, that simply indicates the number of conversations;
\texttt{all\_combinations} that will exhaustively test every combination,
although it ensures good coverage of the inputs,
it can also result in an enormous number of test cases, specially if we use nested forwards;
\texttt{sample(x)}, where $x$ is a number between $0$ and $1$,
will compute all the possible combinations
and take a percentage of all of these.
The second field, \texttt{goal\_style}, is the test's stop condition.
It can be the number of steps taken in the conversation
(let a step be a user message followed by a chatbot's one),
or \texttt{all\_answered} which will stop once the user has completed all of its goals,
this parameter is also accompanied by a \texttt{limit} field which sets a hard limit
making sure that the conversation finishes even if the chatbot is not able to fulfil the user's goals,
or \texttt{all\_answered} which will stop once the user has completed all of its goals,
this parameter is also accompanied by a \texttt{limit} field which sets a hard limit
making sure that the conversation finishes even if the chatbot is not able to fulfil the user's goals.
Lastly, we have the \texttt{interaction\_style},
which lets us set a list of styles that the simulated user will adopt for its conversations.
This styles are predefined and include some like \textit{make spelling mistakes}, \textit{use short phrases}
or \textit{single question}.

\section{User Profiles Generation}\label{sec:profile-generation}
